# IS211_CourseProject

Book Catalogue

Web Version Running @: http://alupotato.pythonanywhere.com/

Notice: Uses Requests and Flask modules which required installations

Requirements

  The project that I went with was the book catalogue project. The base requirement was to give a user an application that lets them keep track of the books that they earn. An authentication system is required for the user to login before reaching a dashboard which displays the user's current list of books. There should be a form where the user can add new books by a search using Google's Book API with an ISBN. The JSON returned from the search should be processed to store the title, author, page count, and average rating of the book. Finally, the application is required to delete books of off their list.

  I went with a few extra credit options that extended the base requirements. I decided to allow the application to support multiple users. This meant adding a way to register an account and store accounts. I also decided to save thumbnails from the JSON data and display them on a user's dashboard/book list. The ability for said JSON data to be searched by title was also incorporated. The last extra requirement was to have the book list up and running hosted on PythonAnywhere.

Database Model

  The first thing I did was model the database schema. In order to fit the requirements, I knew I had to have a books table that contained information about the books to display on a user's dashboard. This information included a book id for the primary key, the book title, the book author, the book page count, the book rating, and the link to a thumbnail of the books cover. I had noticed that for a few JSON requests to Google Books API there were no pages counts, ratings, or thumbnails. Which is why I decided to not enforce no null entries for those fields.

  Due to the extended requirements, a table for accounts is also necessary to keep track of multiple different book lists. The accounts table only needs an account id as the primary key because every id/username should be unique and a field for their passwords. At this point we're missing the link between the books and the accounts that will become the backbone of the book lists. A relation table is needed as many to many relationships are possible with the book lists. So, I made a books accounts relation table that has a book id and account id per row that are referenced from their respective tables. With these 3 tables, I have a sufficient database schema built for the application. I write a script to initialize the database using sqlite3 so it can be used with the main application.
  
Solution

  As this will be a web-based app, I start by doing it the only way I know how at this point: through Flask. A flask app is initialized that help with routing requests and building dynamic pages. The base page is constructed to provide a consistent layout and also link to the login, register, and logout pages from every other page for easy access. The style sheet is also implemented for again a consistent layout, and a better look. 

  The entry point for this web app on the user side is the login page which I also set as the root route, that way users understand that they first need to authenticate. When called the login page displays a login form and can post data from the login form to allows for verification. The login function checks for a matching username and password pair in the accounts table on POST. If there is no match the user gets an appropriate error and is prompted to login again. If successful, it authorizes the user by giving them a session variable of their account id. From there they are redirected to the dashboard where their book list lies.

  Those that don't make it to the dashboard will need to register their own account. As, I have a login required function that is called on the dashboard and add book pages which will redirect unauthorized users back to the login screen. Authorization is checked by looking for the existence of a session account id which is given during authorization. The register page and function are very similar to the login page. The big difference is that POST data gets added to the database on successfully verifying that the username registered on the form isn't the same as an existing account's account id. A successful registration gives the user a session account id and redirects them to the dashboard to begin making their book list.

  If someone wants to keep multiple book lists, at any time they can easily log out from their account to switch accounts or to just not leave the session in place by clicking the log out button. The function the log out button calls just gets rid of the session account id and sends the user back to the login screen.

  Those that decide not to logout right away will be able to see the dashboard page which contains the book list. Unless, it's a new user that doesn't have any books added to their list yet. In that case they won't see a list and instead a prompt to start building one. The book list or lack of booklist is checked by using a sql query that joins the books and accounts book table together with the relevant fields. Only the books that the user themselves have added are displayed through the use of the WHERE clause checking the session account ID. This data is then sent to the dashboard in the form of a list of rows. These rows are iterated on the dashboard's HTML page to create a dynamic table with the relevant fields. The thumbnail image is displayed using the img tag and the book id is displayed for the sake of the remove book function.

  The remove book function is a part of the dashboard page itself. It is displayed to the user in the form of a form on the bottom that takes input asking the book ID of the book they would like to remove from their list. Clicking submit posts that book id to the function where it is utilized in a SQL query that searches for rows in the books accounts table with that book id and the session account id are paired. Which means it is successfully deleting books off of the current user’s book list.
Of course, to remove books you’d have to add books first using the add book page. The html page is setup simply with an option to enter the ISBN or title of a book and then click the submit button to add it to your list. This submit button sends a post request to the add book function which first checks for errors such as: having an empty ISBN and title request or having an ISBN submitted that is not the proper length. If both an ISBN and a title are entered, the ISBN will be processed as it is typically more accurate.

  The way that these search requests are processed is quite simple even though it took me a while to understand. The relevant data is retrieved from the Google Books API using the get and json function from the requests module. Where format strings are used to substitute the appropriate search term, either the entered title or ISBN, for each API link. The ISBN API search link was provided, but the Title API search link was found through the Google Books API’s documentation. 
The processed json leaves us with a Python dictionary that we can easily go through to find what we want. The first order of business is to make sure that the json search didn’t turn up nothing by checking if the total items in the json were equivalent to zero. If they are then the search either didn’t go through or the search term was bad, so an appropriate error message is given in this case. If there are items found then we go through these items entering keys to get the relevant fields we are looking for and assigning them to an appropriately named dictionary key. There’s also a chance for the fields to be empty so we setup a try except block for each item and set it equal to None if it can’t be found or a placeholder image if it’s for the thumbnail.

 If a POST request manages to make it through all that without any errors then it gets the chance to be entered into the database. First the various book attributes are entered into the books table, and then using the power of the last insert row id function we can assign the book id of the newly created book entry to the books accounts table with the session account id. A confirmation message is flashed on success with the title of the book and the user is redirected back to the add book page to add more books. 
